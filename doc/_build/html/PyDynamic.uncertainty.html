

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Evaluation of uncertainties &mdash; PyDynamic 1.2.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PyDynamic 1.2.1 documentation" href="index.html"/>
        <link rel="next" title="Design of deconvolution filters" href="PyDynamic.deconvolution.html"/>
        <link rel="prev" title="Deconvolution in the frequency domain (DFT)" href="Deconvolution in the DFT domain.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyDynamic
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Getting started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Evaluation of uncertainties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-PyDynamic.uncertainty.propagate_DFT">Uncertainty evaluation for the DFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-PyDynamic.uncertainty.propagate_filter">Uncertainty evaluation for digital filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-PyDynamic.uncertainty.propagate_MonteCarlo">Monte Carlo methods for digital filtering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="PyDynamic.deconvolution.html">Design of deconvolution filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyDynamic.misc.html">Miscellaneous</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PyDynamic</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Evaluation of uncertainties</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/PyDynamic.uncertainty.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="evaluation-of-uncertainties">
<h1>Evaluation of uncertainties<a class="headerlink" href="#evaluation-of-uncertainties" title="Permalink to this headline">¶</a></h1>
<p>The evaluation of uncertainties is a fundamental part of the measurement analysis in metrology.
The analysis of dynamic measurements typically involves methods from signal processing, such as
digital filtering or application of the discrete Fourier transform (DFT). For most tasks, methods
are readily available, for instance, as part of <code class="xref py py-mod docutils literal"><span class="pre">scipy.signals</span></code>.
This module of PyDynamic provides the corresponding methods for the evaluation of uncertainties.</p>
<div class="section" id="module-PyDynamic.uncertainty.propagate_DFT">
<span id="uncertainty-evaluation-for-the-dft"></span><h2>Uncertainty evaluation for the DFT<a class="headerlink" href="#module-PyDynamic.uncertainty.propagate_DFT" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-PyDynamic.uncertainty.propagate_DFT" title="PyDynamic.uncertainty.propagate_DFT"><code class="xref py py-mod docutils literal"><span class="pre">PyDynamic.uncertainty.propagate_DFT</span></code></a> module implements methods for the propagation of uncertainties in the
application of the DFT, inverse DFT, deconvolution and multiplication in the frequency domain, transformation from
amplitude and phase to real and imaginary parts and vice versa.</p>
<dl class="docutils">
<dt>The correspoding scientific publications is</dt>
<dd>S. Eichstädt und V. Wilkens
GUM2DFT — a software tool for uncertainty evaluation of transient signals in the frequency domain.
<em>Measurement Science and Technology</em>, 27(5), 055001, 2016.
[DOI: <a class="reference external" href="http://dx.doi.org/10.1088/0957-0233/27/5/055001">10.1088/0957-0233/27/5/055001</a>]</dd>
</dl>
<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.GUM_DFT">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">GUM_DFT</code><span class="sig-paren">(</span><em>x</em>, <em>Ux</em>, <em>N=None</em>, <em>window=None</em>, <em>CxCos=None</em>, <em>CxSin=None</em>, <em>returnC=False</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#GUM_DFT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.GUM_DFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the DFT of the time domain signal x and propagation of the squared uncertainty Ux
associated with the time domain sequence x to the real and imaginary parts of the DFT of x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.ndarray</em>) &#8211; vector of time domain signal values</li>
<li><strong>Ux</strong> (<em>numpy.ndarray</em>) &#8211; covariance matrix associated with x, shape (N,N) or noise variance as float</li>
<li><strong>N</strong> (<em>int, optional</em>) &#8211; length of time domain signal for DFT; N&gt;=len(x)</li>
<li><strong>window</strong> (<em>numpy.ndarray, optional</em>) &#8211; vector of the time domain window values</li>
<li><strong>CxCos</strong> (<em>numpy.ndarray, optional</em>) &#8211; cosine part of sensitivity matrix</li>
<li><strong>CxSin</strong> (<em>numpy.ndarray, optional</em>) &#8211; sine part of sensitivity matrix</li>
<li><strong>returnC</strong> (<em>bool, optional</em>) &#8211; if true, return sensitivity matrix blocks for later use</li>
<li><strong>mask</strong> (<em>ndarray of dtype bool</em>) &#8211; calculate DFT values and uncertainties only at those frequencies where mask is <cite>True</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>F</strong> (<em>numpy.ndarray</em>) &#8211; vector of complex valued DFT values or of its real and imaginary parts</li>
<li><strong>UF</strong> (<em>numpy.ndarray</em>) &#8211; covariance matrix associated with real and imaginary part of F</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Eichstädt and Wilkens <a class="reference internal" href="index.html#eichst2016" id="id2">[Eichst2016]</a></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.GUM_iDFT">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">GUM_iDFT</code><span class="sig-paren">(</span><em>F</em>, <em>UF</em>, <em>Nx=None</em>, <em>Cc=None</em>, <em>Cs=None</em>, <em>returnC=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#GUM_iDFT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.GUM_iDFT" title="Permalink to this definition">¶</a></dt>
<dd><p>GUM propagation of the squared uncertainty UF associated with the DFT values F through the
inverse DFT</p>
<p>The matrix UF is assumed to be for real and imaginary part with blocks:
UF = [[u(R,R), u(R,I)],[u(I,R),u(I,I)]]
and real and imaginary part obtained from calling rfft (DFT for real-valued signal)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> (<em>np.ndarray</em>) &#8211; vector of real and imaginary parts of a DFT result</li>
<li><strong>UF</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with real and imaginary parts of F</li>
<li><strong>Nx</strong> (<em>int, optional</em>) &#8211; number of samples of iDFT result</li>
<li><strong>Cc</strong> (<em>np.ndarray, optional</em>) &#8211; cosine part of sensitivities</li>
<li><strong>Cs</strong> (<em>np.ndarray, optional</em>) &#8211; sine part of sensitivities</li>
<li><strong>returnC</strong> (<em>if true, return sensitivity matrix blocks</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x</strong> (<em>np.ndarry</em>) &#8211; vector of time domain signal values</li>
<li><strong>Ux</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with x</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Eichstädt and Wilkens <a class="reference internal" href="index.html#eichst2016" id="id3">[Eichst2016]</a></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.DFT_deconv">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">DFT_deconv</code><span class="sig-paren">(</span><em>H</em>, <em>Y</em>, <em>UH</em>, <em>UY</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#DFT_deconv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.DFT_deconv" title="Permalink to this definition">¶</a></dt>
<dd><p>Deconvolution in the frequency domain</p>
<p>GUM propagation of uncertainties for the deconvolution X = Y/H with Y and H being the Fourier transform of the measured signal
and of the system&#8217;s impulse response, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>H</strong> (<em>np.ndarray</em>) &#8211; real and imaginary parts of frequency response values (N an even integer)</li>
<li><strong>Y</strong> (<em>np.ndarray</em>) &#8211; real and imaginary parts of DFT values</li>
<li><strong>UH</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with H</li>
<li><strong>UY</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with X</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>X</strong> (<em>np.ndarray</em>) &#8211; real and imaginary parts of DFT values of deconv result</li>
<li><strong>UX</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with real and imaginary part of X</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Eichstädt and Wilkens <a class="reference internal" href="index.html#eichst2016" id="id4">[Eichst2016]</a></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.DFT_multiply">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">DFT_multiply</code><span class="sig-paren">(</span><em>Y</em>, <em>UY</em>, <em>F</em>, <em>UF=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#DFT_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.DFT_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication in the frequency domain</p>
<p>GUM uncertainty propagation for multiplication in the frequency domain, where the second factor F may have an
associated uncertainty. This method can be used, for instance, for the application of a low-pass filter in
the frequency domain or the application of deconvolution as a multiplication with an inverse of known uncertainty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> (<em>np.ndarray</em>) &#8211; real and imaginary parts of the first factor</li>
<li><strong>UY</strong> (<em>np.ndarray</em>) &#8211; covariance matrix or squared uncertainty associated with Y</li>
<li><strong>F</strong> (<em>np.ndarray</em>) &#8211; real and imaginary parts of the second factor</li>
<li><strong>UF</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with F (optional), default is None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>YF</strong> (<em>np.ndarray</em>) &#8211; the product of Y and F</li>
<li><strong>UYF</strong> (<em>np.ndarray</em>) &#8211; the uncertainty associated with YF</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.AmpPhase2DFT">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">AmpPhase2DFT</code><span class="sig-paren">(</span><em>A</em>, <em>P</em>, <em>UAP</em>, <em>keep_sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#AmpPhase2DFT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.AmpPhase2DFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation from amplitude and phase to real and imaginary parts</p>
<p>Calculate the vector F=[real,imag] and propagate the covariance matrix UAP associated with [A, P]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>np.ndarray</em>) &#8211; vector of amplitude values</li>
<li><strong>P</strong> (<em>np.ndarray</em>) &#8211; vector of phase values (in radians)</li>
<li><strong>UAP</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with (A,P)
or vector of squared standard uncertainties [u^2(A),u^2(P)]</li>
<li><strong>keep_sparse</strong> (<em>bool, optional</em>) &#8211; whether to transform sparse matrix to numpy array or not</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>F</strong> (<em>np.ndarray</em>) &#8211; vector of real and imaginary parts of DFT result</li>
<li><strong>UF</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with F</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.DFT2AmpPhase">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">DFT2AmpPhase</code><span class="sig-paren">(</span><em>F</em>, <em>UF</em>, <em>keep_sparse=False</em>, <em>tol=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#DFT2AmpPhase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.DFT2AmpPhase" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation from real and imaginary parts to amplitude and phase</p>
<p>Calculate the matrix
U_AP = [[U1,U2],[U2^T,U3]]
associated with amplitude and phase of the vector F=[real,imag]
with associated covariance matrix U_F=[[URR,URI],[URI^T,UII]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> (<em>np.ndarray</em>) &#8211; vector of real and imaginary parts of a DFT result</li>
<li><strong>UF</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with F</li>
<li><strong>keep_sparse</strong> (<em>bool, optional</em>) &#8211; if true then UAP will be sparse if UF is one-dimensional</li>
<li><strong>tol</strong> (<em>float, optional</em>) &#8211; lower bound for A/uF below which a warning will be issued concerning unreliable results</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>A</strong> (<em>np.ndarray</em>) &#8211; vector of amplitude values</li>
<li><strong>P</strong> (<em>np.ndarray</em>) &#8211; vector of phase values</li>
<li><strong>UAP</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with (A,P)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.AmpPhase2Time">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">AmpPhase2Time</code><span class="sig-paren">(</span><em>A</em>, <em>P</em>, <em>UAP</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#AmpPhase2Time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.AmpPhase2Time" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation from amplitude and phase to time domain</p>
<p>GUM propagation of covariance matrix UAP associated with DFT amplitude A and phase P to the result of
the inverse DFT. Uncertainty UAP is assumed to be given for amplitude and phase with blocks:
UAP = [[u(A,A), u(A,P)],[u(P,A),u(P,P)]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>np.ndarray</em>) &#8211; vector of amplitude values</li>
<li><strong>P</strong> (<em>np.ndarray</em>) &#8211; vector of phase values (in rad)</li>
<li><strong>UAP</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with [A,P]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; vector of time domain values</li>
<li><strong>Ux</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with x</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_DFT.Time2AmpPhase">
<code class="descclassname">PyDynamic.uncertainty.propagate_DFT.</code><code class="descname">Time2AmpPhase</code><span class="sig-paren">(</span><em>x</em>, <em>Ux</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_DFT.html#Time2AmpPhase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_DFT.Time2AmpPhase" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation from time domain to amplitude and phase</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; time domain signal</li>
<li><strong>Ux</strong> (<em>np.ndarray</em>) &#8211; squared uncertainty associated with x</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>A</strong> (<em>np.ndarray</em>) &#8211; amplitude values</li>
<li><strong>P</strong> (<em>np.ndarray</em>) &#8211; phase values</li>
<li><strong>UAP</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with [A,P]</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-PyDynamic.uncertainty.propagate_filter">
<span id="uncertainty-evaluation-for-digital-filtering"></span><h2>Uncertainty evaluation for digital filtering<a class="headerlink" href="#module-PyDynamic.uncertainty.propagate_filter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_filter.FIRuncFilter">
<code class="descclassname">PyDynamic.uncertainty.propagate_filter.</code><code class="descname">FIRuncFilter</code><span class="sig-paren">(</span><em>y</em>, <em>sigma_noise</em>, <em>theta</em>, <em>Utheta=None</em>, <em>shift=0</em>, <em>blow=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_filter.html#FIRuncFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_filter.FIRuncFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncertainty propagation for signal y and uncertain FIR filter theta</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>np.ndarray</em>) &#8211; filter input signal</li>
<li><strong>sigma_noise</strong> (<em>float or np.ndarray</em>) &#8211; when float then standard deviation of white noise in y; when ndarray then point-wise standard uncertainties</li>
<li><strong>theta</strong> (<em>np.ndarray</em>) &#8211; FIR filter coefficients</li>
<li><strong>Utheta</strong> (<em>np.ndarray</em>) &#8211; covariance matrix associated with theta</li>
<li><strong>shift</strong> (<em>int</em>) &#8211; time delay of filter output signal (in samples)</li>
<li><strong>blow</strong> (<em>np.ndarray</em>) &#8211; optional FIR low-pass filter</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; FIR filter output signal</li>
<li><strong>ux</strong> (<em>np.ndarray</em>) &#8211; point-wise uncertainties associated with x</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Elster and Link 2008 <a class="reference internal" href="index.html#elster2008" id="id5">[Elster2008]</a></li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="PyDynamic.deconvolution.html#module-PyDynamic.deconvolution.fit_filter" title="PyDynamic.deconvolution.fit_filter"><code class="xref py py-mod docutils literal"><span class="pre">PyDynamic.deconvolution.fit_filter</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Implement formula for colored noise</li>
<li>Implement formula for covariance calculation</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_filter.IIRuncFilter">
<code class="descclassname">PyDynamic.uncertainty.propagate_filter.</code><code class="descname">IIRuncFilter</code><span class="sig-paren">(</span><em>x</em>, <em>noise</em>, <em>b</em>, <em>a</em>, <em>Uab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_filter.html#IIRuncFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_filter.IIRuncFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncertainty propagation for the signal x and the uncertain IIR filter (b,a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; filter input signal</li>
<li><strong>noise</strong> (<em>float</em>) &#8211; signal noise standard deviation</li>
<li><strong>b</strong> (<em>np.ndarray</em>) &#8211; filter numerator coefficients</li>
<li><strong>a</strong> (<em>np.ndarray</em>) &#8211; filter denominator coefficients</li>
<li><strong>Uab</strong> (<em>np.ndarray</em>) &#8211; covariance matrix for (a[1:],b)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>y</strong> (<em>np.ndarray</em>) &#8211; filter output signal</li>
<li><strong>Uy</strong> (<em>np.ndarray</em>) &#8211; uncertainty associated with y</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Link and Elster <a class="reference internal" href="index.html#link2009" id="id6">[Link2009]</a></li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PyDynamic.uncertainty.propagate_MonteCarlo.SMC" title="PyDynamic.uncertainty.propagate_MonteCarlo.SMC"><code class="xref py py-mod docutils literal"><span class="pre">PyDynamic.uncertainty.propagate_MonteCarlo.SMC</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-PyDynamic.uncertainty.propagate_MonteCarlo">
<span id="monte-carlo-methods-for-digital-filtering"></span><h2>Monte Carlo methods for digital filtering<a class="headerlink" href="#module-PyDynamic.uncertainty.propagate_MonteCarlo" title="Permalink to this headline">¶</a></h2>
<p>The propagation of uncertainties via the FIR and IIR formulae alone does not
enable the derivation of credible intervals, because the underlying distribution
remains unknown. The GUM-S2 Monte Carlo method provides a reference method for the
calculation of uncertainties for such cases.</p>
<p>This module implements Monte Carlo methods for the propagation of uncertainties for digital filtering.</p>
<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_MonteCarlo.MC">
<code class="descclassname">PyDynamic.uncertainty.propagate_MonteCarlo.</code><code class="descname">MC</code><span class="sig-paren">(</span><em>x</em>, <em>Ux</em>, <em>b</em>, <em>a</em>, <em>Uab</em>, <em>runs=1000</em>, <em>blow=None</em>, <em>alow=None</em>, <em>return_samples=False</em>, <em>shift=0</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_MonteCarlo.html#MC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_MonteCarlo.MC" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard Monte Carlo method</p>
<p>Monte Carlo based propagation of uncertainties for a digital filter (b,a)
with uncertainty matrix
<span class="math">\(U_{      heta}\)</span> for :math:`      heta=(a_1,ldots,a_{N_a},b_0,ldots,b_{N_b})^T`</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; filter input signal</li>
<li><strong>Ux</strong> (<em>float or np.ndarray</em>) &#8211; standard deviation of signal noise or covariance matrix associated with x</li>
<li><strong>b</strong> (<em>np.ndarray</em>) &#8211; filter numerator coefficients</li>
<li><strong>a</strong> (<em>np.ndarray</em>) &#8211; filter denominator coefficients</li>
<li><strong>Uab</strong> (<em>np.ndarray</em>) &#8211; uncertainty matrix <span class="math">\(U_    heta\)</span></li>
<li><strong>runs</strong> (<em>int,optional</em>) &#8211; number of Monte Carlo runs</li>
<li><strong>return_samples</strong> (<em>bool, optional</em>) &#8211; whether samples or mean and std are returned</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If &#8216;return_sampes&#8217; is false, the method returns:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>y</strong> (<em>np.ndarray</em>) &#8211; filter output signal</li>
<li><strong>Uy</strong> (<em>np.ndarray</em>) &#8211; uncertainty associated with</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Other wise the method returns</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>Y</strong> &#8211; array of Monte Carlo results</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">np.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Eichstädt, Link, Harris and Elster <a class="reference internal" href="index.html#eichst2012" id="id7">[Eichst2012]</a></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="PyDynamic.uncertainty.propagate_MonteCarlo.SMC">
<code class="descclassname">PyDynamic.uncertainty.propagate_MonteCarlo.</code><code class="descname">SMC</code><span class="sig-paren">(</span><em>x</em>, <em>noise_std</em>, <em>b</em>, <em>a</em>, <em>Uab=None</em>, <em>runs=1000</em>, <em>Perc=None</em>, <em>blow=None</em>, <em>alow=None</em>, <em>shift=0</em>, <em>return_samples=False</em>, <em>phi=None</em>, <em>theta=None</em>, <em>Delta=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyDynamic/uncertainty/propagate_MonteCarlo.html#SMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyDynamic.uncertainty.propagate_MonteCarlo.SMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequential Monte Carlo method</p>
<p>Sequential Monte Carlo propagation for a digital filter (b,a) with uncertainty
matrix <span class="math">\(U_{       heta}\)</span> for :math:`      heta=(a_1,ldots,a_{N_a},b_0,ldots,b_{N_b})^T`</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>np.ndarray</em>) &#8211; filter input signal</li>
<li><strong>noise_std</strong> (<em>float</em>) &#8211; standard deviation of signal noise</li>
<li><strong>b</strong> (<em>np.ndarray</em>) &#8211; filter numerator coefficients</li>
<li><strong>a</strong> (<em>np.ndarray</em>) &#8211; filter denominator coefficients</li>
<li><strong>Uab</strong> (<em>np.ndarray</em>) &#8211; uncertainty matrix <span class="math">\(U_    heta\)</span></li>
<li><strong>runs</strong> (<em>int, optional</em>) &#8211; number of Monte Carlo runs</li>
<li><strong>Perc</strong> (<em>list, optional</em>) &#8211; list of percentiles for quantile calculation</li>
<li><strong>blow</strong> (<em>np.ndarray</em>) &#8211; optional low-pass filter numerator coefficients</li>
<li><strong>alow</strong> (<em>np.ndarray</em>) &#8211; optional low-pass filter denominator coefficients</li>
<li><strong>shift</strong> (<em>int</em>) &#8211; integer for time delay of output signals</li>
<li><strong>return_samples</strong> (<em>bool, otpional</em>) &#8211; whether to return y and Uy or the matrix Y of MC results</li>
<li><strong>theta</strong> (<em>phi,</em>) &#8211; parameters for AR(MA) noise model
:<span class="math">\(\epsilon(n)  = \sum_k \phi_k\epsilon(n-k) + \sum_k      heta_k w(n-k) + w(n)\)</span>
with :<span class="math">\(w(n)\sim N(0,noise_std^2)\)</span></li>
<li><strong>Delta</strong> (<em>float,optional</em>) &#8211; upper bound on systematic error of the filter</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If return_samples is False:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>y</strong> (<em>np.ndarray</em>) &#8211; filter output signal (Monte Carlo mean)</li>
<li><strong>Uy</strong> (<em>np.ndarray</em>) &#8211; uncertainties associated with y (Monte Carlo point-wise std)</li>
<li><strong>Quant</strong> (<em>np.ndarray</em>) &#8211; quantiles corresponding to percentiles Perc (if not None) at</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Otherwise:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>Y</strong> &#8211; array of all Monte Carlo results</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">np.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li>Eichstädt, Link, Harris, Elster <a class="reference internal" href="index.html#eichst2012" id="id8">[Eichst2012]</a></li>
</ul>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="PyDynamic.deconvolution.html" class="btn btn-neutral float-right" title="Design of deconvolution filters" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Deconvolution in the DFT domain.html" class="btn btn-neutral" title="Deconvolution in the frequency domain (DFT)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, S Eichstädt (PTB), I Smith (NPL).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.2.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>